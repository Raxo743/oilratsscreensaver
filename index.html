<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OilRats Screensaver</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      background-color: #f0f0f0;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    let gravityEnabled = true;
    const friction = 0.9;
    const size = 60;

    const img = new Image();
    img.src = "oilrats.png";

    const magnetImg = new Image();
    magnetImg.src = "ak48.png";

    class Square {
      constructor(x, y, isMagnet = false) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.vx = 0;
        this.vy = 0;
        this.dragging = false;
        this.isMagnet = isMagnet;
        this.heldDown = false;
      }

      draw() {
        if (this.isMagnet && magnetImg.complete) {
          ctx.drawImage(magnetImg, this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
        } else if (img.complete) {
          ctx.drawImage(img, this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
        } else {
          ctx.fillStyle = this.isMagnet ? "red" : "gray";
          ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
        }
      }

      update() {
        if (!this.dragging) {
          if (gravityEnabled) {
            this.vy += 0.5; // gravity
          }

          this.x += this.vx;
          this.y += this.vy;

          // Collisions with edges
          if (this.y + this.size / 2 > canvas.height) {
            this.y = canvas.height - this.size / 2;
            this.vy *= -friction;
            this.vx *= friction;
          }
          if (this.y - this.size / 2 < 0) {
            this.y = this.size / 2;
            this.vy *= -friction;
          }
          if (this.x + this.size / 2 > canvas.width) {
            this.x = canvas.width - this.size / 2;
            this.vx *= -friction;
          }
          if (this.x - this.size / 2 < 0) {
            this.x = this.size / 2;
            this.vx *= -friction;
          }
        }
        this.draw();
      }

      isPointInside(px, py) {
        return (
          px >= this.x - this.size / 2 &&
          px <= this.x + this.size / 2 &&
          py >= this.y - this.size / 2 &&
          py <= this.y + this.size / 2
        );
      }

      getBounds() {
        return {
          left: this.x - this.size / 2,
          right: this.x + this.size / 2,
          top: this.y - this.size / 2,
          bottom: this.y + this.size / 2,
        };
      }
    }

    function resolveCollision(s1, s2) {
      const b1 = s1.getBounds();
      const b2 = s2.getBounds();

      const overlapX = Math.min(b1.right, b2.right) - Math.max(b1.left, b2.left);
      const overlapY = Math.min(b1.bottom, b2.bottom) - Math.max(b1.top, b2.top);

      if (overlapX <= 0 || overlapY <= 0) return;

      if (overlapX < overlapY) {
        if (s1.x < s2.x) {
          s1.x -= overlapX / 2;
          s2.x += overlapX / 2;
        } else {
          s1.x += overlapX / 2;
          s2.x -= overlapX / 2;
        }
        const vx1 = s1.vx;
        s1.vx = s2.vx;
        s2.vx = vx1;
        s1.vy *= friction;
        s2.vy *= friction;
      } else {
        if (s1.y < s2.y) {
          s1.y -= overlapY / 2;
          s2.y += overlapY / 2;
        } else {
          s1.y += overlapY / 2;
          s2.y -= overlapY / 2;
        }
        const vy1 = s1.vy;
        s1.vy = s2.vy;
        s2.vy = vy1;
        s1.vx *= friction;
        s2.vx *= friction;
      }
    }

    const squares = [];
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * (canvas.width - size) + size / 2;
      const y = Math.random() * (canvas.height / 2);
      squares.push(new Square(x, y));
    }

    // Magnet square
    const magnetSquare = new Square(canvas.width / 2, canvas.height / 2, true);
    squares.push(magnetSquare);

    let draggingSquare = null;
    let offsetX = 0;
    let offsetY = 0;

    // Buttons
    const toggleButton = { x: 20, y: 20, size: 40 }; // blue
    const boostButton = { size: 40 }; // green, top right corner

    function updateBoostButtonPosition() {
      boostButton.x = canvas.width - boostButton.size - 20;
      boostButton.y = 20;
    }
    updateBoostButtonPosition();
    window.addEventListener("resize", updateBoostButtonPosition);

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Gravity toggle button
      if (
        mouseX >= toggleButton.x &&
        mouseX <= toggleButton.x + toggleButton.size &&
        mouseY >= toggleButton.y &&
        mouseY <= toggleButton.y + toggleButton.size
      ) {
        gravityEnabled = !gravityEnabled;
        if (!gravityEnabled) {
          squares.forEach(sq => {
            sq.vx *= 0.1;
            sq.vy *= 0.1;
          });
        }
        return;
      }

      // Boost button
      if (
        mouseX >= boostButton.x &&
        mouseX <= boostButton.x + boostButton.size &&
        mouseY >= boostButton.y &&
        mouseY <= boostButton.y + boostButton.size
      ) {
        squares.forEach(sq => {
          if (!sq.isMagnet) {
            const speed = Math.sqrt(sq.vx * sq.vx + sq.vy * sq.vy) * 1.25 + 2;
            const angle = Math.random() * Math.PI * 2;
            sq.vx = Math.cos(angle) * speed;
            sq.vy = Math.sin(angle) * speed;
          }
        });
        return;
      }

      // Dragging squares
      for (let i = squares.length - 1; i >= 0; i--) {
        if (squares[i].isPointInside(mouseX, mouseY)) {
          draggingSquare = squares[i];
          draggingSquare.dragging = true;
          if (draggingSquare.isMagnet) draggingSquare.heldDown = true;
          offsetX = mouseX - draggingSquare.x;
          offsetY = mouseY - draggingSquare.y;
          draggingSquare.vx = 0;
          draggingSquare.vy = 0;
          break;
        }
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (!draggingSquare) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      draggingSquare.x = mouseX - offsetX;
      draggingSquare.y = mouseY - offsetY;
    });

    canvas.addEventListener("mouseup", () => {
      if (draggingSquare) {
        draggingSquare.vx = 0;
        draggingSquare.vy = 0;
        draggingSquare.dragging = false;
        if (draggingSquare.isMagnet) draggingSquare.heldDown = false;
        draggingSquare = null;
      }
    });

    canvas.addEventListener("mouseleave", () => {
      if (draggingSquare) {
        draggingSquare.vx = 0;
        draggingSquare.vy = 0;
        draggingSquare.dragging = false;
        if (draggingSquare.isMagnet) draggingSquare.heldDown = false;
        draggingSquare = null;
      }
    });

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Blue gravity toggle
      ctx.fillStyle = "blue";
      ctx.fillRect(toggleButton.x, toggleButton.y, toggleButton.size, toggleButton.size);

      // Green boost button
      ctx.fillStyle = "green";
      ctx.fillRect(boostButton.x, boostButton.y, boostButton.size, boostButton.size);

      // Handle collisions
      for (let i = 0; i < squares.length; i++) {
        for (let j = i + 1; j < squares.length; j++) {
          resolveCollision(squares[i], squares[j]);
        }
      }

      // Magnet pull
      if (magnetSquare.heldDown) {
        squares.forEach(sq => {
          if (!sq.isMagnet) {
            const dx = magnetSquare.x - sq.x;
            const dy = magnetSquare.y - sq.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

            const pullStrength = 0.15;
            sq.vx += (dx / dist) * pullStrength;
            sq.vy += (dy / dist) * pullStrength;

            const floatStrength = 0.02;
            sq.x += dx * floatStrength;
            sq.y += dy * floatStrength;
          }
        });
      }

      // Update + draw
      squares.forEach(sq => sq.update());

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>

